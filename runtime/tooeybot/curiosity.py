"""
Curiosity System - Phase 2

Manages the creation and tracking of curiosity-driven tasks.
Curiosity is productive exploration, not wandering.
"""

import json
from dataclasses import dataclass
from datetime import datetime, date
from pathlib import Path
from typing import List, Dict, Any, Optional
from enum import Enum
import logging

from .cycle import CuriosityProposal
from .budgets import AgentBudgets, BudgetEnforcer

logger = logging.getLogger(__name__)


class CuriosityCategory(Enum):
    """Categories of curiosity-driven work."""
    VERIFICATION = "verification"      # Verify assumptions or results
    DOCUMENTATION = "documentation"    # Document findings or processes
    ROBUSTNESS = "robustness"         # Improve error handling, edge cases
    EXPLORATION = "exploration"        # Explore related topics


@dataclass
class CuriosityTask:
    """
    A task created from curiosity.
    
    Tracks origin and lineage for analysis.
    """
    task_id: str
    description: str
    justification: str
    category: CuriosityCategory
    estimated_value: float
    priority: str
    
    # Lineage tracking
    parent_task_id: str
    depth: int  # 0 = from user task, 1 = from curiosity task, etc.
    created_at: datetime
    
    def to_inbox_format(self) -> str:
        """Format as inbox task block."""
        return f"""
---
task_id: {self.task_id}
priority: {self.priority}
origin: curiosity
parent_task: {self.parent_task_id}
curiosity_category: {self.category.value}
curiosity_depth: {self.depth}
context: |
  Generated by curiosity during task {self.parent_task_id}.
  Category: {self.category.value}
  Estimated value: {self.estimated_value}
  Justification: {self.justification}
---
{self.description}

## Success criteria
- Curiosity goal achieved
- Findings documented if relevant
"""

    def to_dict(self) -> Dict[str, Any]:
        return {
            "task_id": self.task_id,
            "description": self.description,
            "justification": self.justification,
            "category": self.category.value,
            "estimated_value": self.estimated_value,
            "priority": self.priority,
            "parent_task_id": self.parent_task_id,
            "depth": self.depth,
            "created_at": self.created_at.isoformat(),
        }


class CuriosityManager:
    """
    Manages curiosity-driven task creation.
    
    Ensures curiosity is:
    - Bounded by budgets
    - Tracked for analysis
    - Productive, not wandering
    """
    
    def __init__(
        self,
        agent_home: Path,
        budgets: AgentBudgets,
        budget_enforcer: BudgetEnforcer
    ):
        self.agent_home = agent_home
        self.budgets = budgets
        self.budget_enforcer = budget_enforcer
        
        self.curiosity_log = agent_home / "logs" / "curiosity.jsonl"
        self.curiosity_log.parent.mkdir(parents=True, exist_ok=True)
        
        self.tasks_inbox = agent_home / "tasks" / "inbox.md"
    
    def process_proposals(
        self,
        proposals: List[CuriosityProposal],
        parent_task_id: str,
        parent_depth: int = 0
    ) -> List[CuriosityTask]:
        """
        Process curiosity proposals and create tasks.
        
        Returns list of created tasks.
        """
        created = []
        
        for proposal in proposals:
            # Check budget
            can_create, reason = self.budget_enforcer.check_can_create_curiosity_task(
                depth=parent_depth + 1
            )
            
            if not can_create:
                logger.info(f"Cannot create curiosity task: {reason}")
                self._log_rejection(proposal, parent_task_id, reason)
                continue
            
            # Check value threshold
            if proposal.estimated_value < self.budgets.min_curiosity_value_threshold:
                logger.debug(f"Proposal below value threshold: {proposal.estimated_value}")
                self._log_rejection(proposal, parent_task_id, "below_value_threshold")
                continue
            
            # Create the task
            task = self._create_task(proposal, parent_task_id, parent_depth + 1)
            created.append(task)
            
            # Update budget
            self.budgets.record_curiosity_task()
            
            # Add to inbox
            self._add_to_inbox(task)
            
            # Log creation
            self._log_creation(task)
            
            logger.info(f"Created curiosity task: {task.task_id}")
        
        return created
    
    def _create_task(
        self,
        proposal: CuriosityProposal,
        parent_task_id: str,
        depth: int
    ) -> CuriosityTask:
        """Create a CuriosityTask from a proposal."""
        task_id = self._generate_task_id()
        
        try:
            category = CuriosityCategory(proposal.category)
        except ValueError:
            category = CuriosityCategory.EXPLORATION
        
        return CuriosityTask(
            task_id=task_id,
            description=proposal.description,
            justification=proposal.justification,
            category=category,
            estimated_value=proposal.estimated_value,
            priority=proposal.priority,
            parent_task_id=parent_task_id,
            depth=depth,
            created_at=datetime.now(),
        )
    
    def _generate_task_id(self) -> str:
        """Generate a unique task ID."""
        timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
        return f"curiosity-{timestamp}"
    
    def _add_to_inbox(self, task: CuriosityTask) -> None:
        """Add task to the inbox."""
        current = ""
        if self.tasks_inbox.exists():
            current = self.tasks_inbox.read_text()
        
        self.tasks_inbox.write_text(current + "\n" + task.to_inbox_format())
    
    def _log_creation(self, task: CuriosityTask) -> None:
        """Log task creation."""
        entry = {
            "event": "curiosity_task_created",
            "timestamp": datetime.now().isoformat(),
            "task": task.to_dict(),
        }
        with open(self.curiosity_log, "a") as f:
            f.write(json.dumps(entry) + "\n")
    
    def _log_rejection(
        self,
        proposal: CuriosityProposal,
        parent_task_id: str,
        reason: str
    ) -> None:
        """Log proposal rejection."""
        entry = {
            "event": "curiosity_proposal_rejected",
            "timestamp": datetime.now().isoformat(),
            "proposal": proposal.to_dict(),
            "parent_task_id": parent_task_id,
            "reason": reason,
        }
        with open(self.curiosity_log, "a") as f:
            f.write(json.dumps(entry) + "\n")
    
    def get_daily_stats(self) -> Dict[str, Any]:
        """Get curiosity statistics for today."""
        today = date.today().isoformat()
        
        created_today = 0
        rejected_today = 0
        categories = {}
        
        if self.curiosity_log.exists():
            for line in self.curiosity_log.read_text().strip().split("\n"):
                if not line.strip():
                    continue
                try:
                    entry = json.loads(line)
                    if entry.get("timestamp", "")[:10] == today:
                        if entry.get("event") == "curiosity_task_created":
                            created_today += 1
                            cat = entry.get("task", {}).get("category", "unknown")
                            categories[cat] = categories.get(cat, 0) + 1
                        elif entry.get("event") == "curiosity_proposal_rejected":
                            rejected_today += 1
                except:
                    pass
        
        return {
            "date": today,
            "created": created_today,
            "rejected": rejected_today,
            "remaining_budget": max(0, self.budgets.max_curiosity_tasks_per_day - created_today),
            "categories": categories,
        }
    
    def get_task_lineage(self, task_id: str) -> List[Dict[str, Any]]:
        """Get the lineage (ancestry) of a curiosity task."""
        lineage = []
        
        if self.curiosity_log.exists():
            tasks_by_id = {}
            for line in self.curiosity_log.read_text().strip().split("\n"):
                if not line.strip():
                    continue
                try:
                    entry = json.loads(line)
                    if entry.get("event") == "curiosity_task_created":
                        task_data = entry.get("task", {})
                        tasks_by_id[task_data.get("task_id")] = task_data
                except:
                    pass
            
            # Trace back through parents
            current_id = task_id
            while current_id in tasks_by_id:
                task_data = tasks_by_id[current_id]
                lineage.append(task_data)
                current_id = task_data.get("parent_task_id", "")
        
        return lineage
